#!/bin/bash

# defaults
#########################
_source=`pwd`
_destination="/src"
_image="jmervine/vimrc"
_rm="true"

# load configurations
#########################
test -e $HOME/.dockmerc \
  && source $HOME/.dockmerc

test -e $(pwd)/.dockmerc \
  && source $(pwd)/.dockmerc

# helper methods
#########################
function parg {
  local sopt="$1"
  local lopt="$2"
  local desc="$3"

  [[ -z "$desc" ]] \
    && desc="see 'docker run --help' for details"

  if [ -z "$sopt" ]; then
    printf '      --%-14s %s\n' "$lopt" "$desc"
  else
    printf '  -%s, --%-14s %s\n' "$sopt" "$lopt" "$desc"
  fi
}

function options_printer {
  parg "s" "source"        "local host source directory"
  parg "d" "destination"   "remote host source directory"
  parg "i" "image"         "image"
  parg "H" "hostname"
  parg "p" "publish"
  parg "w" "workdir"
  parg "w" "workdir"
  parg "n" "name"
  parg "N" "net"
  parg "r" "rm"
  parg ""  "no-rm"         "do not remove container when finished"
  parg ""  "cpuset"
  parg ""  "memory"
  parg "v" "volumes"
  parg ""  "volumes-from"
  parg "D" "dryrun"        "only print what would be executed"
  parg ""  "save"          "save configuration to local .dockmerc file"
}

function show_help {
  echo "Usage: $0 [template] [options] [-- command]

Simple wraper for quickly spooling up docker comtainers a development
environments.

  Templates:
  - vim     jmervine/vimrc:latest
  - node    node:latest
  - ruby    ruby:latest
  - rails   rails:latest
  - python  python:2
  - golang  golang:latest

  Template configurations must be defined as the first argument and are applied
  and then overwritten by any passed arguments.

  Options:
$(options_printer)

  Defaults:
  - source       '${_source}'
  - destination  '${_destination}'
  - image        '${_image}'
  - rm           '${_rm}'
  - workdir      destination directory

External Configuration

dockme can be configured via an external file. It will look for a file named
.dockmerc in your home directory and the current working directory, unless one
is passed via the configuration argument. *All arguments passed will supersede
arguments configured by dockmerc files.*

  Configuration Precedence

  > ARGUMENTS
  --> .dockmerc
  ----> ~/.dockmerc

  Configuration Sample:

  # file: .dockmerc
  _source=/path/to/source
  _destination=/path/to/dest
  _image=username/image:tag
  _rm=true
  _workdir=/path/to/workdir
  _name=container_name
  _net=host
  _cpuset=2
  _memory=1g
  _volumes=/some/vol:/some/path
  _volumes_from=volume_container
  _command="echo 'a command'"
" | less
}

function messing_arg_error {
  local arg=$1
  printf 'ERROR: Missing value for %s\n-----\n' "$arg"
  show_help
  exit
}

function save_config {
  echo "# file: .dockmerc" > .dockmerc

  [[ -z "${_source}" ]] \
    || echo "_source=${_source}" >> .dockmerc

  [[ -z "${_destination}" ]] \
    || echo "_destination=${_destination}" >> .dockmerc

  [[ -z "${_image}" ]] \
    || echo "_image=${_image}" >> .dockmerc

  [[ -z "${_rm}" ]] \
    || echo "_rm=${_rm}" >> .dockmerc

  [[ -z "${_workdir}" ]] \
    || echo "_workdir=${_workdir}" >> .dockmerc

  [[ -z "${_publish}" ]] \
    || echo "_publish=${_publish}" >> .dockmerc

  [[ -z "${_hostname}" ]] \
    || echo "_hostname=${_hostname}" >> .dockmerc

  [[ -z "${_name}" ]] \
    || echo "_name=${_name}" >> .dockmerc

  [[ -z "${_net}" ]] \
    || echo "_net=${_net}" >> .dockmerc

  [[ -z "${_cpuset}" ]] \
    || echo "_cpuset=${_cpuset}" >> .dockmerc

  [[ -z "${_memory}" ]] \
    || echo "_memory=${_memory}" >> .dockmerc

  [[ -z "${_volumes}" ]] \
    || echo "_volumes=\"${_volumes}\"" >> .dockmerc

  [[ -z "${_volumes_from}" ]] \
    || echo "_volumes_from=\"${_volumes_from}\"" >> .dockmerc

  [[ -z "${_command}" ]] \
    || echo "_command=${_command}" >> .dockmerc

  echo "+ configuration saved to .dockmerc"
  cat .dockmerc
}

# handle templates
if [ "$#" -gt 0 ]; then
  case "$1" in
    vim|vimrc)
      _image="jmervine/vimrc:latest"
      shift;;
    ruby|rb)
      _image="ruby:latest"
      shift;;
    rails)
      _image="rails:latest"
      shift;;
    python|py)
      _image="python:2"
      shift;;
    node|nodejs)
      _image="node:latest"
      shift;;
    go|golang)
      _image="golang:latest"
      shift;;
  esac
fi

while [ "$#" -gt 0 ]; do
  case $1 in
    -h|-\?|--help)
      show_help
      exit
      ;;

    # source
    -s|--source)
      if [ "$#" -gt 1 ]; then
        _source=$2
        shift 2
        continue
      else
        missing_arg_error "source"
      fi
      ;;
    --source=?*)
      _source=${1#*=}
      shift
      continue;;
    --source=)
      missing_arg_error "source";;

    # destination
    -d|--destination)
      if [ "$#" -gt 1 ]; then
        _destination=$2
        shift 2
        continue
      else
        missing_arg_error "destination"
      fi
      ;;
    --destination=?*)
      _destination=${1#*=}
      shift
      continue;;
    --destination=)
        missing_arg_error "destination";;

    # image
    -i|--image)
      if [ "$#" -gt 1 ]; then
        _image=$2
        shift 2
        continue
      else
        missing_arg_error "image"
      fi
      ;;
    --image=?*)
      _image=${1#*=}
      shift
      continue;;
    --image=)
        missing_arg_error "image";;

    # hostname
    -H|--hostname)
      if [ "$#" -gt 1 ]; then
        _hostname=$2
        shift 2
        continue
      else
        missing_arg_error "hostname"
      fi
      ;;
    --hostname=?*)
      _hostname=${1#*=}
      shift
      continue;;
    --hostname=)
        missing_arg_error "hostname";;

    # publish
    -p|--publish)
      if [ "$#" -gt 1 ]; then
        _publish=$2
        shift 2
        continue
      else
        missing_arg_error "publish"
      fi
      ;;
    --publish=?*)
      _publish=${1#*=}
      shift
      continue;;
    --publish=)
        missing_arg_error "publish";;

    # workdir
    -w|--workdir)
      if [ "$#" -gt 1 ]; then
        _workdir=$2
        shift 2
        continue
      else
        missing_arg_error "workdir"
      fi
      ;;
    --workdir=?*)
      _workdir=${1#*=}
      shift
      continue;;
    --workdir=)
        missing_arg_error "workdir";;

    # name
    -n|--name)
      if [ "$#" -gt 1 ]; then
        _name=$2
        shift 2
        continue
      else
        missing_arg_error "name"
      fi
      ;;
    --name=?*)
      _name=${1#*=}
      shift
      continue;;
    --name=)
        missing_arg_error "name";;

    # net
    -N|--net)
      if [ "$#" -gt 1 ]; then
        _net=$2
        shift 2
        continue
      else
        missing_arg_error "net"
      fi
      ;;
    --net=?*)
      _net=${1#*=}
      shift
      continue;;
    --net=)
        missing_arg_error "net";;

    # rm
    --no-rm)
        unset _rm
        shift
        continue;;

    # rm
    -r|--rm)
        _rm='true'
        shift
        continue;;

    # dryrun
    -D|--dryrun)
        _dryrun='true'
        shift
        continue;;

    # save
    --save)
        _save='true'
        shift
        continue;;

    # cpuset
    --cpuset)
      if [ "$#" -gt 1 ]; then
        _cpuset=$2
        shift 2
        continue
      else
        missing_arg_error "cpuset"
      fi
      ;;
    --cpuset=?*)
      _cpuset=${1#*=}
      shift
      continue;;
    --cpuset=)
        missing_arg_error "cpuset";;

    # memory
    --memory)
      if [ "$#" -gt 1 ]; then
        _memory=$2
        shift 2
        continue
      else
        missing_arg_error "memory"
      fi
      ;;
    --memory=?*)
      _memory=${1#*=}
      shift
      continue;;
    --memory=)
        missing_arg_error "memory";;

    # volumes
    -v|--volumes)
      if [ "$#" -gt 1 ]; then
        _volumes=$2
        shift 2
        continue
      else
        missing_arg_error "volumes"
      fi
      ;;
    --volumes=?*)
      _volumes=${1#*=}
      shift
      continue;;
    --volumes=)
        missing_arg_error "volumes";;

    # volumes_from
    --volumes-from)
      if [ "$#" -gt 1 ]; then
        _volumes-from=$2
        shift 2
        continue
      else
        missing_arg_error "volumes-from"
      fi
      ;;
    --volumes-from=?*)
      _volumes-from=${1#*=}
      shift
      continue;;
    --volumes-from=)
        missing_arg_error "volumes-from";;

    --)
      shift
      break;;

    -?*)
      printf 'WARN: Unknown option (ignored): %s\n' "$1" >&2
      shift;;

    *)
      shift;;
  esac
done

if [ "$#" -gt 0 ]; then
  _command=$@
fi

docker="docker run -it"

if [ -z "${_workdir}" ]; then
  docker="${docker} --workdir=${_destination}"
else
  docker="${docker} --workdir=${_workdir}"
fi

[[ "${_rm}" = "true" ]] \
  && docker="${docker} --rm"

[[ -z "${_name}" ]] \
  || docker="${docker} --name=${_name}"

[[ -z "${_net}" ]] \
  || docker="${docker} --net=${_net}"

[[ -z "${_cpuset}" ]] \
  || docker="${docker} --cpuset=${_cpuset}"

[[ -z "${_memory}" ]] \
  || docker="${docker} --memory=${_memory}"

[[ -z "${_hostname}" ]] \
  || docker="${docker} --hostname=${_hostname}"

[[ -z "${_publish}" ]] \
  || docker="${docker} --publish=${_publish}"

[[ -z "${_destination}" ]] \
  && docker="${docker} --volume=${_source}"

[[ -z "${_destination}" ]] \
  || docker="${docker} --volume=${_source}:${_destination}"

if [[ ! -z "${_volumes}" ]]; then
  for v in $(echo ${_volumes}); do
    vols="${vols} --volume=${v}"
  done
  docker="${docker} ${vols}"
fi

if [[ ! -z "${_volumes_from}" ]]; then
  for v in $(echo ${_volumes_from}); do
    vols="${vols} --volumes-from=${v}"
  done
  docker="${docker} ${vols}"
fi

docker="${docker} ${_image}"

[[ -z "${_command}" ]] \
  || docker="${docker} ${_command}"

[[ -z "${_save}" ]] \
  || save_config

echo "+ $docker"

([[ -z "${_dryrun}" ]] \
  && exec $docker) || true

# vim: ft=sh
